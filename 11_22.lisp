(defun complement-base (x)
 (second (assoc x '((a t) (g c) (c g) (t a)))))

(defun complement-strand (dna-strand)
  (let ((result nil))
    (dolist (base dna-strand (reverse result))
      (push (complement-base base) result))))

(defun make-double (dna-strand)
  (do ((x dna-strand (rest x))
        (result nil
                (cons (list (first x) (complement-base (first x))) result)))
    ((null x) (reverse result))))

(defun count-bases (strand)
 (let ((a-count 0)
       (t-count 0)
       (g-count 0)
       (c-count 0))
  (labels ((count-single-strand (base)
            (cond ((equal base 'a) (incf a-count))
                  ((equal base 't) (incf t-count))
                  ((equal base 'g) (incf g-count))
                  ((equal base 'c) (incf c-count)))))
   (dolist (e strand)
    (cond ((atom e) (count-single-strand e))
          (t (count-single-strand (first e))
             (count-single-strand (second e)))))
   (list (list 'a a-count)
         (list 't t-count)
         (list 'g g-count)
         (list 'c c-count)))))

(defun prefixp (strand-a strand-b)
 (do ((a strand-a (rest a))
      (b strand-b (rest b)))
    ((null a) t)
    (if (not (equal (first a) (first b)))
     (return nil))))

(defun appearsp (strand-a strand-b)
 (do ((b strand-b (rest b)))
  ((null b) nil)
  (if (prefixp strand-a b)
   (return t))))

(defun coverp (strand-a strand-b)
 (do ((b strand-b (nthcdr (length strand-a) b)))
  ((null b) t)
  (if (not (prefixp strand-a b))
   (return nil))))

(defun prefix (n strand-a)
 (do ((i 0 (+ i 1))
      (a strand-a (rest a))
      (result nil (cons (first a) result)))
  ((equal i n) (reverse result))))

(defun kernel (strand)
 (do ((i 1 (+ i 1)))
  ((coverp (prefix i strand) strand)
   (prefix i strand))))
